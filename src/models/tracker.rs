use super::{
    common::{InfoHash, IntervalDuration, NumOfBytes, PeerId, PeerKey, Port},
    torrent::TorrentStats,
};
use crate::{
    constants,
    utils::Loggable,
    worker::{self, TaskOutput},
};
use serde::{ser::SerializeSeq, Deserialize, Serialize};
use std::{fmt, net::IpAddr};
use ts_utils::{
    bencode::{self, Bencode},
    bencode_dict, bencode_int, bencode_str,
    serde::deserialize_u8_to_bool,
    MultiMap,
};

/// Represents the event type for announcing a download status to a BitTorrent tracker.
/// The `AnnounceEvent` enum is used to indicate the different states of the announcement.
#[derive(Debug, Serialize, Deserialize, PartialEq)]
#[serde(rename_all = "lowercase")]
pub enum AnnounceEvent {
    /// An announcement using `started` is sent when a download first begins.
    Started,

    /// Downloaders send an announcement using `stopped` when they cease downloading.
    Stopped,

    /// `completed` is sent when the download is complete.
    /// No `completed` is sent if the file was complete when `started`.
    Completed,

    /// `paused` is sent when the peer is a partial seed.
    /// See: http://www.bittorrent.org/beps/bep_0021.html#tracker-scrapes
    Paused,

    /// When request is one performed at regular intervals.
    None,
}

impl From<u32> for AnnounceEvent {
    fn from(val: u32) -> Self {
        match val {
            2 => AnnounceEvent::Started,
            1 => AnnounceEvent::Completed,
            3 => AnnounceEvent::Stopped,
            _ => AnnounceEvent::None,
        }
    }
}

#[derive(Debug, Serialize, Deserialize)]
/// Represents an announce request sent to a BitTorrent tracker.
///
/// An `AnnounceRequest` contains information about the client's download/upload
/// progress and requests information about peers from the tracker.
pub struct AnnounceRequest {
    /// The 20-byte SHA1 hash of the value of the info key from the Metainfo file
    pub info_hash: InfoHash,

    /// The port number that the client is listening on.
    pub port: Port,

    /// unique ID for the client, generated by the client at startup.
    /// example: `-AZ2060-`
    /// https://www.bittorrent.org/beps/bep_0003.html
    pub peer_id: PeerId,

    #[serde(default)]
    /// The total amount uploaded (since the client sent the `started` event to the tracker).
    pub uploaded: NumOfBytes,

    #[serde(default)]
    /// The total amount downloaded (since the client sent the `started` event to the tracker).
    pub downloaded: NumOfBytes,

    #[serde(default)]
    /// The number of bytes this peer still has to download.
    pub left: NumOfBytes,

    #[serde(default = "default_compact")]
    #[serde(deserialize_with = "deserialize_u8_to_bool")]
    /// Setting this to `true` indicates that the client accepts a compact response.
    pub compact: bool,

    #[serde(default = "default_no_peer_id")]
    #[serde(deserialize_with = "deserialize_u8_to_bool")]
    /// Indicates that the tracker can omit peer id field in peers dictionary.
    /// This option is ignored if compact is enabled.
    pub no_peer_id: bool,

    /// If specified, must be one of started, completed, stopped, (or empty which is the same as not being specified).
    /// If not specified, then this request is one performed at regular intervals.
    pub event: Option<AnnounceEvent>,

    /// Number of peers that the client would like to receive from the tracker.
    pub numwant: Option<u32>,

    /// An additional identification that is not shared with any other peers.
    /// It is intended to allow a client to prove their identity should their IP address change.
    /// The key should remain the same for a particular infohash during a torrent session.
    /// https://www.bittorrent.org/beps/bep_0007.html
    pub key: PeerKey,
}

impl Loggable for AnnounceRequest {
    fn log(&self) -> String {
        format!("announce request: {:?}", self)
    }
}

fn default_compact() -> bool {
    true
}

fn default_no_peer_id() -> bool {
    true
}

#[derive(Debug, Serialize, Deserialize, Default)]
/// Represents the response sent by tracker for `AnnounceRequest`.
pub struct AnnounceResponse {
    /// The number of peers with the entire file, aka "seeders".
    #[serde(rename = "complete")]
    pub seeders: u32,

    /// The number of non-seeder peers, aka "leechers".
    #[serde(rename = "incomplete")]
    pub leechers: u32,

    /// Interval in seconds that the client should wait between sending regular requests to the tracker.
    pub interval: IntervalDuration,

    #[serde(rename = "min interval")]
    /// Minimum announce interval. Clients must not reannounce more frequently than this.
    pub min_interval: IntervalDuration,

    /// This list contains IPv4 addresses of peers that support the BitTorrent protocol over IPv4.
    /// It is optional and may be absent if there are no IPv4 peers in the response.
    pub peers: Option<ResponsePeerList>,

    /// This list contains IPv6 addresses of peers that support the BitTorrent protocol over IPv6.
    /// It is optional and may be absent if there are no IPv6 peers in the response.
    pub peers6: Option<ResponsePeerList>,

    #[serde(rename = "warning message")]
    /// Similar to failure reason, but the response still gets processed normally.
    /// The warning message is shown just like an error.
    pub warning_message: Option<String>,
}

impl Loggable for AnnounceResponse {
    fn log(&self) -> String {
        format!("announce response: {:?}", self)
    }
}

impl Bencode for AnnounceResponse {
    fn requires_sort(&self) -> bool {
        false
    }

    fn capacity(&self) -> usize {
        128
    }
}

/// Represents a scrape request sent to a BitTorrent tracker.
#[derive(Debug, Deserialize, Default)]
#[serde(from = "ScrapeRequestMap")]
pub struct ScrapeRequest {
    pub info_hashes: Vec<InfoHash>,
}

type ScrapeRequestMap<'a> = MultiMap<&'a str, InfoHash, ahash::RandomState>;

impl<'a> From<ScrapeRequestMap<'a>> for ScrapeRequest {
    fn from(mut map: ScrapeRequestMap<'a>) -> Self {
        match map.remove("info_hash") {
            Some(vec) => Self { info_hashes: vec },
            None => Self::default(),
        }
    }
}

/// Represents the response sent by tracker for `ScrapeRequest`.
#[derive(Debug, Default, Serialize)]
pub struct ScrapeResponse {
    pub files: Vec<(InfoHash, TorrentStats)>,
}

impl ScrapeResponse {
    pub fn new(files: Vec<(InfoHash, TorrentStats)>) -> Self {
        Self { files }
    }
}

impl Bencode for ScrapeResponse {
    fn bencode(&self) -> bencode::Result<bytes::Bytes> {
        let files = &self.files;
        let capacity = 100 * files.len();
        let mut serializer = bencode::Serializer::with_capacity(capacity);

        serializer.start_dict();
        bencode_str!(serializer, constants::TRACKER_RESPONSE_FILES);
        serializer.start_dict();

        for (info_hash, stats) in files {
            bencode_file(&mut serializer, info_hash, stats);
        }

        serializer.end_dict();
        serializer.end_dict();

        Ok(serializer.finalize())
    }
}

fn bencode_file(serializer: &mut bencode::Serializer, info_hash: &InfoHash, stats: &TorrentStats) {
    serializer.encode_bytes(info_hash.as_ref());
    bencode_dict!(
        serializer,
        constants::TRACKER_RESPONSE_COMPLETE => bencode_int!(serializer, stats.seeders),
        constants::TRACKER_RESPONSE_DOWNLOADED => bencode_int!(serializer, stats.completed),
        constants::TRACKER_RESPONSE_INCOMPLETE => bencode_int!(serializer, stats.leechers)
    );
}

/// Represents a full scrape response for a BitTorrent tracker.
#[derive(Debug)]
pub struct FullScrapeResponse {
    pub ser: Option<bencode::Serializer>,
}

impl FullScrapeResponse {
    pub fn new() -> Self {
        Self {
            ser: Some(bencode::Serializer::new()),
        }
    }

    pub fn output(&mut self) -> Option<bytes::Bytes> {
        match self.ser.take() {
            Some(serializer) => Some(serializer.finalize()),
            None => None,
        }
    }

    pub fn bencode<'a, T>(&mut self, files: T)
    where
        T: Iterator<Item = (&'a InfoHash, &'a TorrentStats)>,
    {
        if let Some(ref mut serializer) = self.ser {
            serializer.start_dict();
            bencode_str!(serializer, constants::TRACKER_RESPONSE_FILES);
            serializer.start_dict();

            for (info_hash, stats) in files {
                bencode_file(serializer, info_hash, stats);
            }

            serializer.end_dict();
            serializer.end_dict();
        }
    }
}

/// Represents the error response sent by the tracker for `announce` or `scrape` request.
#[derive(Debug, Serialize, Deserialize, Default)]
pub struct TrackerError {
    #[serde(rename = "failure reason")]
    /// The value is a human-readable error message as to why the request failed.
    pub failure_reason: String,
}

impl Bencode for TrackerError {
    fn requires_sort(&self) -> bool {
        false
    }

    fn capacity(&self) -> usize {
        self.failure_reason.len()
    }
}

impl From<&str> for TrackerError {
    fn from(err: &str) -> Self {
        Self {
            failure_reason: err.to_string(),
        }
    }
}

impl From<String> for TrackerError {
    fn from(err: String) -> Self {
        Self {
            failure_reason: err,
        }
    }
}

impl From<worker::Error> for TrackerError {
    fn from(err: worker::Error) -> Self {
        Self {
            failure_reason: err.to_string(),
        }
    }
}

impl From<TaskOutput> for AnnounceResponse {
    fn from(output: TaskOutput) -> Self {
        match output {
            TaskOutput::Announce(response) => response,
            _ => unreachable!(),
        }
    }
}

impl From<TaskOutput> for ScrapeResponse {
    fn from(output: TaskOutput) -> Self {
        match output {
            TaskOutput::Scrape(response) => response,
            _ => unreachable!(),
        }
    }
}

/// Represents a non-compact peer information in the BitTorrent protocol.
///
/// A `NonCompactPeer` contains information about a peer's IP address, unique
/// identifier (if available), and port number.
///
/// # Examples
///
/// ```
/// use ts_tracker::models::tracker::NonCompactPeer;
/// use ts_tracker::models::common::{Port, PeerId};
/// use std::net::{IpAddr, Ipv4Addr};
///
/// let peer = NonCompactPeer {
///     ip: IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)),
///     peer_id: Some(PeerId([0; 20])),
///     port: Port(6881),
/// };
/// ```
#[derive(Debug, Serialize, Deserialize)]
pub struct NonCompactPeer {
    /// The peer's IP address.
    pub ip: IpAddr,

    /// The unique identifier of the peer (optional).
    pub peer_id: Option<PeerId>,

    /// The port on which the peer is listening for incoming connections.
    pub port: Port,
}

/// Represents the list of peers in the response from a BitTorrent tracker.
///
/// A `ResponsePeerList` can be either compact or non-compact, containing
/// information about the peers in the form of byte vectors or structured
/// `NonCompactPeer` instances.
///
/// # Examples
///
/// ```
/// use ts_tracker::models::tracker::{ResponsePeerList, NonCompactPeer};
/// use ts_tracker::models::common::{Port, PeerId};
/// use std::net::{IpAddr, Ipv4Addr};
///
/// let compact_list = ResponsePeerList::Compact(vec![1, 2, 3, 4, 5]);
/// let non_compact_list = ResponsePeerList::NonCompact(vec![
///     NonCompactPeer {
///         ip: IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)),
///         peer_id: Some(PeerId([0; 20])),
///         port: Port(6881),
///     },
/// ]);
/// ```
#[derive(Deserialize)]
pub enum ResponsePeerList {
    /// A compact list of peer information represented as byte vectors.
    Compact(Vec<u8>),
    /// A non-compact list of structured peer information.
    NonCompact(Vec<NonCompactPeer>),
}

impl Serialize for ResponsePeerList {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            ResponsePeerList::Compact(peers) => {
                if peers.is_empty() {
                    serializer.serialize_none()
                } else {
                    serializer.serialize_bytes(peers)
                }
            }
            ResponsePeerList::NonCompact(peers) => {
                if peers.is_empty() {
                    return serializer.serialize_none();
                }

                let mut seq = serializer.serialize_seq(Some(peers.len()))?;
                for peer in peers {
                    seq.serialize_element(peer)?;
                }

                seq.end()
            }
        }
    }
}

impl fmt::Display for ResponsePeerList {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "{}",
            match self {
                ResponsePeerList::Compact(peers) => format!("{:?}", peers),
                ResponsePeerList::NonCompact(peers) => format!("{:?}", peers),
            }
        )
    }
}

impl fmt::Debug for ResponsePeerList {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        fmt::Display::fmt(self, f)
    }
}

/// Serializes an object into a bencode `Bytes` with a given capacity.
macro_rules! try_into_bytes {
    ($from:ty) => {
        impl TryFrom<$from> for bytes::Bytes {
            type Error = bencode::Error;

            fn try_from(value: $from) -> Result<Self, Self::Error> {
                value.bencode()
            }
        }
    };
}

try_into_bytes!(AnnounceResponse);
try_into_bytes!(ScrapeResponse);
try_into_bytes!(TrackerError);
